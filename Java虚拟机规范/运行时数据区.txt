1 pc寄存器(program counter)
* Java虚拟机可以支持多线程同时执行，每一条Java虚拟机线程都有自己的pc寄存器。
* 任意时刻，一条java虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法(current method)
* 如果这个方法不是native的，那pc寄存器就保存java虚拟机正在执行的字节码指令的地址，如果是native的，pc寄存器的值是undefined。
* pc寄存器的容量至少能保存一个returnAddrress类型的数据或者一个与平台相关的本地指针的值。

2 java虚拟机栈
* 每一条java虚拟机线程都有自己的私有的java虚拟机栈(java virtual machine stack)
* 这个栈与线程同时创建，用于存储栈帧(frame)
* java虚拟机栈的作用与传统语言(例如c)中的栈非常类似，用于存储局部变量与一些尚未算好的结果。另外在方法的调用和返回中也扮演很重要的角色。
* 因为除了栈帧的出栈和入栈外，java虚拟机栈不会再受其它因素的影响，所有栈帧可以在堆中分配，java虚拟机栈所需的内存不需要保证是连续的。
* java虚拟机规范即允许java虚拟机栈被实现成固定大小，也允许根据计算动态扩展和收缩。
* 如果采用固定大小，需允许在线程创建的时候独立选定。
* java虚拟机实现应当提供给程序员或最终用户调节虚拟机栈初始容量的手段，对于可以动态扩展和收缩的java虚拟机栈来说，则应当提供调节其最大，最小容量的手段。
* 如果线程请求分配的栈容量超过java虚拟机允许的最大容量，java虚拟机将会抛出StackOverflowError异常。如果java虚拟机可以动态扩展，并且在尝试扩展的时候
  无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出OutofMemeryError异常。

3 java堆(heap)
* 在java虚拟机中，堆是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。
* java堆在虚拟机启动的时候就创建了，它存储了被自动内存管理系统(automatic storage management system)，也就是常说的garbage collector所管理的各种对象
* 这些对象不需要显示的销毁。
* java堆的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。java堆所使用的内存不需要保证是连续的。
* java虚拟机实现应当提供给程序员或者最终的用户调节java堆初始容量的手段，对于可以动态扩展和收缩的java堆来说，则应当提供调节其最大最小容量的手段。
* 如果实际所需的堆超过了自动内存管理能提供的最大容量，那java虚拟机将会抛出一个OutoMemoryError异常。

4 方法区(method area)
* 在java虚拟机中，方法区是可供各个线程共享的运行时内存区域。
  与传统语言中的编译代码存储区(storage area for compiled code)或者操作系统进程的正文段(text segment)
  的作用非常类似，存储了每一个类的结构信息，例如，运行时常量池(runtime constant pool),字段和方法数据，构造函数和普通方法的字节码内容
  还包括一些在类，实例，接口初始化的特殊方法
* 方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以在这个区域不实现垃圾收集与压缩。
* 这个版本的java虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。
* 方法区的容量可以是固定的，也可以随着程序执行动态扩展，并在不需要过多空间的时候自动收缩。 在实际内存空间中可以是不连续的。
* java虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态扩展和收缩方法区来说，应当提供调剂其最大和最小容量的手段。
* 如果方法区的内存空间不能满足内存分配请求，那么java虚拟机将抛出一个OutofMemoryError异常。

4 运行时常量池(runtime constant pool)
* 运行时常量池是class文件中每一个类或接口的常量池表的运行时表示形式，它包括了若干种不同的常量，
  从编译期可知的数值字面量到必须在运行期间解析后才能获得的方法或字段引用。
* 运行时常量池类似于传统语言中的符号表(symbol table)，不过它存储数据的范围比通常意义上的符号表更为广泛。
* 运行时常量池都在java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。

5 本地方法栈(native method stack)
* java虚拟机实现可能会使用到传统的栈(通常称为C stack)来支持native方法(使用java以外的其它语言编写的方法)执行。称为本地方法栈
* 当java虚拟机使用其它语言来实现指令集解释器时，也可以使用本地方法栈。
* 如果java虚拟机不支持native方法，或者本身不依赖传统栈，可以不提供本地方法栈，如果支持，这个栈一般会在创建的时候按线程分配。

6 栈帧(frame)
* 栈帧是用来存储数据和部分过程结果的数据结构。同时也用来处理动态链接(dynamic linking),方法返回值和异常分派(dispatch exception)。
* 栈帧随着方法的调用而创建，随着方法结束而销毁-无论正常还是异常完成。栈帧的存储空间由创建它的线程分配在java虚拟机栈中
* 每一个栈帧都有自己的本地变量表(local variable)，操作数栈(operand stack)和指向当前方法所属的类的运行时常量池的应用
* 栈帧中还允许携带与java虚拟机实现相关的一些附加信息，例如，对程序调试提供支持的信息
* 本地变量和操作数栈的容量在编译器确定，并通过相关方法的code属性保存及提供给栈帧使用。因此栈帧的数据结构的大小仅仅取决于java虚拟机的实现。
* 在某条线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的。这个栈帧称为当前栈帧。对于的方法称为当前方法，定义的类称为当前类
* 栈帧是线程本地私有的数据，不可能在一个栈帧中引用另一个线程的栈帧。

7 局部变量表
* 每个栈帧内部都包含一组称为局部变量的变量列表。栈帧的局部变量表的长度由编译期决定，存储在方法的code属性中。
* 一个局部变量可以保存一个类型为boolean，byte，char，short，int，float，reference，returnAddress，两个可以保存long，double类型数据。
* 局部变量表通过索引来进行定位访问。首个局部变量索引值为0，索引值大于等于0，小于长度。
* long和double类型的数据占用两个连续的局部变量，采用较小的索引来定位。
* 局部变量索引值不一定要求是偶数，java虚拟机也不要求double和long类型的数据采用64位对齐的方法连续存储在局部变量表中。虚拟机实现
  可以自由地选择合适的方式，通过两个局部变量表来存储一个double或long类型的值。
* java虚拟机使用局部变量表来完成方法调用时的参数传递。当调用方法时，它的参数将会被传递到局部变量表中从0开始的连续位置上。
  当调用实例方法时，0位置上存储该实例方法所在对象的引用。

8 操作数栈
* 每个栈帧内部都包含一个称为操作数栈的后进先出(LIFO)栈。栈帧中操作数栈最大深度由编译期决定，并且通过方code属性保存
* 栈帧在刚刚创建时，操作数栈是空的。java虚拟机提供一些字节码指令来从局部变量表或者对象实例字段中复制常量或变量值到操作数栈中，
  也提供一些指令用于从操作数栈中取走数据，操作数据以及把操作结果重新入栈。
* 操作数栈也用来准备调用方法的参数以及接收方法返回结果。

9 动态链接
* 每个栈帧内部都包含一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现动态链接。
* 一个方法若想调用其它方法或者访问成员变量，则需要通过符号引用来表示，动态链接的作用是将这些符号引用转换为直接的引用。对变量的访问转换为运行时存储结构中的偏移量
* 由于对其它类中方法和变量进行了晚期绑定，所以即便那些类发生变化，也不会影响调用它们的方法。

10 对象的表示
* java虚拟机规范不强制规定对象的内部结构应当如何表示
  在oracle某些java虚拟机实现中，指向对象实例的引用是一个指向句柄的指针，这个句柄包含两个指针，其中一个指向一张表格，此表格包含该对象的各个方法
  还包含指向Class对象的指针，那个class对象用来表示该对象的类型。句柄的另一个指针指向分配在堆中的对象的实例数据。

