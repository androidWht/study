1 当编译一个Java程序时候，会得到程序中每个类或者接口的独立class文件。虽然独立的文件看上去毫无关联，实际上通过接口符号相互联系。
  或者与Java API文件相联系。
2 class文件把它索引的引用符号保存在一个地方-常量池。每一个class文件都又一个常量池。每一个被Java虚拟机装载的类或者接口都有一份
  内部版本的常量池，称作运行时常量池，特定于实现的数据结构，映射class文件中的常量池。
3 解析的过程就是根据符号查找实体，再把符号引用替换成直接引用的过程。
4 常量池按照一系列项组织。每个项都拥有唯一的索引。
5 连接不仅仅包括把符号引用替换成直接引用，还包括检查正确性和权限。
6 装载 - 连接 - 初始化
  验证 - 准备 - 解析
  虚拟机实现有选择何时解析符号引用的自由，但都应该再程序第一次实际访问一个符号引用时才抛出异常。
7 动态状态类 
	Class.forName(String className,boolean initialize,ClassLoader loader);
		加载，连接，初始化
	ClassLoader.loadClass(String className,boolean resovle);
		加载，连接
	ClassLoader创建时可以指定双亲委托的父ClassLoader，如果没有指定，则使用系统类加载器，如果指定为null，则使用启动类装载器。
8 初始类装载器
	加载某个Class,能够加载成功的，则称为这个Class的初始类加载器。
  定义类装载器
    加载某个Class，实际由其加载的，则称为这个Class定义类装载器。
9 CONSTANT_Class_info解析。
	数组类型：由一个[开始。如果当前类装载器已经被记录为被解析的数组类的初始装载器，就是用相同的类。
	否则，虚拟机执行下列步骤：如果数组元素是一个引用类型，虚拟机用当前类装载器解析元素类型。如果数组元素是基本类型，
	那么虚拟机会立即创建关于那个元素类型的新数组类型，维数也在此时确定，然后创建一个Class实例来代表这个类型。如果数组元素是
	引用类型，那么这一步骤发生在解析元素类型之后。
	如果数组元素是引用类型，数组类型被标记为由元素类型的类装载器定义的。如果是数组元素是基本类型，数组类会被标记为启动类装载器定义的
	
	非数组类和接口：
	步骤1a:装载类型或者任何超类型。
		第一步：虚拟机检查类型是否已经被装载进了当前命名空间(每个类装载器，Java虚拟机维护了一张列表，记录了所以将其作为初始类装载器的类型)
		第二步：使用当前类装载器加载引用类型，在双亲委托加载链中，装载该类型的装载器被标记被定义类装载器，在这个过程中所涉及的所以装载器被标记为引用类装载器。
		第三步：检查二进制数据格式是否正确
		第四步：检查加载超类直到Object。从Object返回时，加载所有接口。
	在步骤1a中可能抛出的错误：
		1 如果虚拟机直接调用启动类装载器(而不是通过一次findSystemClass调用)，而它无法确定或者生成所请求类型的二进制数组，虚拟机抛出NoClassDefFoundError.
		2 如果用户自定义的类装载器通过一次findSystemClass()调用委派给启动类装载器，而启动类装载器无法确定或生成所请求的二进制数据，findSystemClass()方法
		  产生ClassNotFoundError中断，同样用户自定义类装载器通过loadClass()调用委派给另一个用户自定义的类装载器，同样抛出ClassNotFoundError
		3 如果二进制数组被确定或者生成了，但它的结构正确，虚拟机抛出ClassFormatError异常。
		4 如果二进制数组被确定或者生成了，但它的版本无法识别(Java文件主版本号或者次版本号)，虚拟机 抛出UnsupportedClassVersionError。
		5 如果二进制数组被确定或者生成了，但在类或者接口之后跟着的并非是所需的名字，虚拟机抛出NoClassDefFoundError.
		6 如果组织良好的二进制数据被传递为defineClass()，但是包含的类或者接口的名字已经在当前类装载器命名空间存在了，defineClass()产生LinkageError。
		7 如果类不包含超类，并且不是Object，抛出ClassFormatError。
		8 如果一个类或接口的超类或接口是自己，抛出ClassCircularityError.
		9 如果类型引用的超类其实是个接口，或者引用的超接口其实是个类，虚拟机抛出IncompatibleClassChangeError。
		
	步骤1b:检查访问权限	
		如果发起引用的类型没有访问被引用类型的权限，虚拟机抛出IllegalAccessError异常。逻辑上来说，步骤1b是校验的一部分，但是
		并非在正式校验阶段完成。检查访问权限总是在1a之后，以确保符号引用指向的类型被装载进正确的命名空间，这是符号引用的一部分。
		
	步骤2：连接并初始化类型和任何超类。在步骤1完成后，类型被装载成功，但是没有进行必要的连接和初始化。类型所有超类和超连接也被装载了，但没有进行必要的连接和初始化。
		   类型被使用前必须进行连接和初始化，初始化是按照继承结构从上到下处理。
		1b:校验类型
		校验类型是连接校验阶段的开始。校验过程虚拟机可能要求装载新的类型来确定字节码是否符合java语义。如果在校验阶段出错，抛出VerifyError.
		2b:准备类型
			为类变量以及随实现不同而又差别的数据结构(比如方法表)分配内存。
		2c:可选的步骤，解析类型。
			解析被引用类型中的常量池。例如，A引用B，B引用C，解析B时可选的可以解析C。如果在解析C过程中出错，不能抛出异常，要在
			C被主动使用时再抛出异常。
		2d:初始化类型
			自上而下，依次初始化，如果初始化报错，如果时Error类型错误，直接抛出，如果不是，包装抛出ExceptionInInitializerError.
10 解析CONSTANT_Fieldref_info
		1 搜索指定类型和名字的字段。当前类型 -> 父接口 -> 父类型。如果搜索失败，抛出NoSuchFieldError.	
		2 检查当前类型是否有权限访问这个字段。如果没有权限访问，抛出IllegalAccessError.
		3 虚拟机把这个入口标记为已解析，并在这个常量池入口的数据中存放指向这个字段的直接引用。
11 解析CONSTANT_Methodref_info			
		1 如果被解析的类型是一个接口，虚拟机抛出IncompatibleClassChangeError.
		2 查找方法，当前类型 -> 超类型 -> 超接口。如果没有找到抛出NuSuchMethodError
		3 如果方法是抽象方法，抛出AbstractMethodError.
		4 检查访问权限，如果没有访问权限，抛出IllegalAccessError.
		5 虚拟机把这个入口标记为已解析，并在这个常量池入口的数据中存放指向这个字段的直接引用。
12 解析CONSTANT_InterfaceMethodRef_info
		1 检查被解析类型是否是一个接口，如果不是，抛出IncompatiableClassChangeError异常。
		2 搜索方法，当前接口 - 超接口。如果没有找到抛出NoSuchMethodError异常。
		3 虚拟机把这个入口标记为已解析，并在这个常量池入口的数据中存放指向这个字段的直接引用。
13 解析CONSTANT_String_info
		虚拟机必须把一个指向内部字符串对象的引用放到要被解析的常量池入口数据中去。该字符串对象必须与CONSTATN_Utf8_info相符。
		每个虚拟机内部必须维护一张内部列表，记录了字符串对象引用，任何特定的字符串只出现一次。所有字面表达的字符串都在解析
		CNOSTANT_String_info入口的过程中被拘留了。
14 解析其它类型的入口
		CONSTANT_Integer_info CONSTATN_Long_info CONSTANT_Float_info和CONSTANT_Double_info入口不需要被解析，直接使用字面值。
		CONSTANT_Utf8_info和CONSTANT_NameAndType_info类型入口永远不会被指令直接引用，它们只有通过其它入口类型才能被引用，并且在那些入口被解析才被解析。
15 装载约束
		引用类型和被引用类型并非由同一个初始类装载器装载，虚拟机必须确保在字段或者方法描述符中提及的类型在不同命名空间中保持一致。
		为确保虚拟机能够保证命名空间的一致性，虚拟机规范定义了几种约束，每一个java虚拟机都必须维护一个关于这些约束的内部列表。
		每个约束基本上都表明一个命名空间中的某个名字必须和另一个命名空间中的同一个名字指向同一类型数据。
		<C,Ld>^L1  C表示类型，Ld表示定义类装载器，L1表示定义类加载器。
		1 当解析一个包含在<C,L1>中的符合引用(它指向的是类<D,L2>)声明的类型T的字段时，虚拟机必须产生如下装载约束：T^L1 = T^L2.
		2 当解析一个包含在<C,L1>中的符合引用(它指向的是一个方法，返回值T0，参数<T1,T2....Tn>,在类<C,L2>中声明)，必须产生如下约束
		  T0^L1 = T0^L1 ..... Tn^L1 = Tn^L2
		3 当<C,L1>重载方法(该方法返回值T0,参数T1..Tn,在类<C,L2>中声明) 虚拟机必须产生如下约束
		  T0^L1 = T0^L1 ..... Tn^L1 = Tn^L2
16 编译时常量
	    被初始化为编译时常量的静态final变量的引用，在编译时被解析为常量值的一个本地拷贝。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		