1 当编译一个Java程序时候，会得到程序中每个类或者接口的独立class文件。虽然独立的文件看上去毫无关联，实际上通过接口符号相互联系。
  或者与Java API文件相联系。
2 class文件把它索引的引用符号保存在一个地方-常量池。每一个class文件都又一个常量池。每一个被Java虚拟机装载的类或者接口都有一份
  内部版本的常量池，称作运行时常量池，特定于实现的数据结构，映射class文件中的常量池。
3 解析的过程就是根据符号查找实体，再把符号引用替换成直接引用的过程。
4 常量池按照一系列项组织。每个项都拥有唯一的索引。
5 连接不仅仅包括把符号引用替换成直接引用，还包括检查正确性和权限。
6 装载 - 连接 - 初始化
  验证 - 准备 - 解析
  虚拟机实现由选择何时解析符号引用的自由，但都应该再程序第一次实际访问一个符号引用时才抛出异常。
7 动态状态类 
	Class.forName(String className,boolean initialize,ClassLoader loader);
		加载，连接，初始化
	ClassLoader.loadClass(String className,boolean resovle);
		加载，连接
	ClassLoader创建时可以指定双亲委托的父ClassLoader，如果没有指定，则使用系统类加载器，如果指定为null，则使用启动类装载器。
8 初始类装载器
	加载某个Class,能够加载成功的，则称为这个Class的初始类加载器。
  定义类装载器
    加载某个Class，实际由其加载的，则称为这个Class定义类装载器。
9 CONSTANT_Class_info解析。
	数组类型：由一个[开始。如果当前按类装载器已经被记录为被解析的数组类的初始装载器，就是用相同的类。
	否则，虚拟机执行下列步骤：如果数组元素是一个引用类型，虚拟机用当前类装载器解析元素类型。如果数组元素是基本类型，
	那么虚拟机会立即创建关于那个元素类型的新数组类型，维数也在此时确定，然后创建一个Class实例来代表这个类型。如果数组元素是
	引用类型，那么这一步骤发生在解析元素类型之后。
	如果数组元素是引用类型，数组类型被标记为由元素类型的类装载器定义的。如果是数组元素是基本类型，数组类会被标记为启动类装载器定义的
	
	非数组类和接口：
	步骤1a:装载类型或者任何超类型。
		第一步：虚拟机检查类型是否已经被装载进了当前命名空间(每个类装载器，Java虚拟机维护了一张列表，记录了所以将其作为初始类装载器的类型)
		第二步：使用当前类装载器加载引用类型，在双亲委托加载链中，装载该类型的装载器被标记被定义类装载器，在这个过程中所涉及的所以装载器被标记为引用类装载器。
		第三步：检查二进制数据格式是否正确
		第四步：检查加载超类直到Object。从Object返回时，加载所有接口。
	在步骤1a中可能抛出的错误：
		1 如果虚拟机直接调用启动类装载器(而不是通过一次findSystemClass调用)，而它无法确定或者生成所请求类型的二进制数组，虚拟机抛出NoClassDefFoundError.
		2 如果用户自定义的类装载器通过一次findSystemClass()调用委派给启动类装载器，而启动类装载器无法确定或生成所请求的二进制数据，findSystemClass()方法
		  产生ClassNotFoundError中断，同样用户自定义类装载器通过loadClass()调用委派给另一个用户自定义的类装载器，同样抛出ClassNotFoundError
		3 如果二进制数组被确定或者生成了，但它的结构正确，虚拟机抛出ClassFormatError异常。
		4 如果二进制数组被确定或者生成了，但它的版本无法识别(Java文件主版本号或者次版本号)，虚拟机 抛出UnsupportedClassVersionError。
		5 如果二进制数组被确定或者生成了，但在类或者接口之后跟着的并非是所需的名字，虚拟机抛出NoClassDefFoundError.
		6 如果组织良好的二进制数据被传递为defineClass()，但是包含的类或者接口的名字已经在当前类装载器命名空间存在了，defineClass()产生LinkageError。
		7 如果类不包好超类，并且不是Object，抛出ClassFormatError。
		8 如果一个类或接口的超类或接口是自己，抛出ClassCircularityError.
		9 如果类型引用的超类其实是个接口，或者引用的超接口其实是个类，虚拟机抛出IncompatibleClassChangeError。
		
	步骤1b:检查访问权限	
		如果发起引用的类型没有访问被引用类型的权限，虚拟机抛出IllegalAccessError异常。逻辑上来说，步骤1b是校验的一部分，但是
		并非在正式校验阶段完成。检查访问权限总是在1a之后，以确保符号引用指向的了些被装载进正确的命名空间，这是符号引用的一部分。
		
	步骤2：连接并初始化类型和任何超类。在步骤1完成后，类型被装载成功，但是没有进行必要的连接和初始化。类型所有超类和超连接也被装载了，但没有进行必要的连接和初始化。
		   类型被使用前必须进行连接和初始化，初始化是按照继承结构从上到下处理。
		1b:校验类型
		校验类型是连接校验阶段的开始。校验过程虚拟机可能要求装载新的类型来确定字节码是否符合java语义。如果在校验阶段出错，抛出VerifyError.
		2b:准备类型
			为类变量以及随实现不同而又差别的数据结构(比如方法表)分配内存。
		2c:可选的步骤，解析类型。
			解析被引用类型中的常量池。例如，A引用B，B引用C，解析B时可选的可以解析C。如果在解析C过程中出错，不能抛出异常，要在
			C被主动使用时再抛出异常。
		2d:初始化类型
			自上而下，依次初始化，如果初始化报错，如果时Error类型错误，直接抛出，如果不是，包装抛出ExceptionInInitializerError.
			
			
		
		
		
		
		
		
		
		
		
		
		
		
		
		