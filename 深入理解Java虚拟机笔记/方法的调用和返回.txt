1 方法类型：实例方法和静态方法。
  实例方法调用必须通过实例调用，而类方法不需要。
  实例方法使用动态绑定，而类方法使用静态绑定。
2 当Java虚拟机调用一个类方法时，它会基于对象引用的类型(通常在编译时可知)来选择调用的方法。
  相反，当虚拟机调用一个实例方法时，它会基于对象实际的类(只能在运行时得到)来选择调用的方法。
3 invokevirtual  把对象引用和方法 参数从栈中弹出，调用常量池索引指向的实例方法。
  invokestatic   把方法参数从栈中弹出，调用常量池索引指向的类方法。
4 方法的调用
	1 根据局部变量，操作数栈以及特定虚拟机实现需要的其它所有的信息，创建方法栈帧，再将新栈压入Java栈。
5 invokespecial 根据引用的类型来调用实例方法，而不是根据对象的类型来调用的时候。
  invokeinterface 当引用的类型是接口的时候。
  
  invokespecial调用<init>方法(构造器)。
  invokespecial调用私有方法。
  invokespecial调用super方法。
  
  Java虚拟机是否使用静态绑定来执行invokespecial指令(或者使用一个特殊的动态绑定)取决于所指向类是否设置了ACC_SUPER标志。
  JDK1.0.2版本以前各个版本中，invokespecial指令的名称为invokenonvirtual，而且总会导致静态绑定使用，结果却是无法保证所有
  的情况下JAVA语言语义的正确实现，这是指令集中的一个bug。以后的版本做了修复，添加ACC_SUPER标志，指明Java虚拟机应该使用
  哪一种语义来执行class文件按字节码所遇到的invokespecial指令。如果没有设置标志，虚拟机使用旧指令，否则使用新语义。
  旧语义：虚拟机再任何情况下都使用静态绑定。新语义除了调用超类方法外，其它情况一律使用静态绑定。
  当虚拟机解析一个invokespecial指令中指向超类方法的符号引用时，它会动他搜寻当前当前类的超类，找到最近的超类中该方法的实现。
  
  当引用的类型为类的使用使用invokevirtual，当应用的类型为接口的时候，使用invokeinterface。
  这样区分的原因在于Java不能像使用类引用那样，使用许多与方法表偏移量相关的假设。对于类引用来所，无论对象的实际类是什么，
  方法再方法表中始终占据相同的位置，但对于接口引用来说，情况就不是这样了，位于不同类的同一方法处于不同的位置。
  
  调用速度
  invokestatic >= invokespecial > invokevirtual > invokeinterface。
  invokeinferface每次调用都需要搜索方法表。