															第一章 计算机系统漫游
1、	计算机信息：位+上下文
2、	c语言是贝尔实验室的Dennis Ritchie于1969 - 1973年创建的，ANSI在1989年颁布了ANSI C标准，后来交于ISO负责。
3、 编译系统：预处理器 -  编译器 - 汇编器 - 链接器
4、 hello.c - hello.i - hello.s - hello.o
5、 GNU项目是1984年由Richard Stallman发起的一个免税的慈善项目，已经开发出了除内核外的所有主要的部件环境：
	EMACS编辑器、GCC编译期、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其他的一些部件。
6、	总线：贯穿整个系统的是一组电子管道，称做总线，它携带信息字节并负责在各个部件间传递。通常总线贝尔设计成传递定长的字节块，即字(word)。
7、I/O设备：系统与外部世界联系的通道。每个I/O设备都是通过一个控制器或者适配器与I/O总线相连。
8、主存：是一个临时存储设备，在程序执行时，用来存放程序和程序的处理数据。从物理上来说，主存是一组动态随机存取存储器(DRAM)芯片组成。
		 从逻辑上来讲，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。
9、处理器：中央处理单元(CPU),是解释和执行指令的引擎。核心是一个字长的寄存器称为pc计数器。ALU-算术/逻辑单元。
			加载：将一个字节或者一个字从主存复制到寄存器，以覆盖寄存器原来的值。
			存储：将一个字节或者一个字从寄存器复制到主存，以覆盖原来的值。
			操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术操作，并将结果存储到一个寄存器中，以覆盖该寄存器原来的值。
			跳转：从指令中复制一个字，并将这个字复制到程序计算器中，以覆盖原来的值。
		指令集结构：描述的是每条机器代码指令的效果
		位体系结构：描述的是处理器实际上是如何实现的
			
			
			
			
			
			
			
	 
			
			
			
			
			
			
			
			
			
			
												第六章 存储器的层次结构
1，概述
		在计算机模型中，cpu负责指令的执行，存储器系统负责数据和指令的存储，存储器系统被组织为一个大的字节数组，cpu能以常量的时间访问每一个字节。
		在存储器系统内部，实际是由不同容量，成本，访问速度存储器组成的层次结构。寄存器 - 高速缓存存储器 - 主存储器 - 磁盘 - 网络。
		高速的存储器是作为低速存储器的缓存，存储器访问在1一个周期内就能访问，高速缓存存储器需要1 - 30个周期，主存储器50 - 200 ，磁盘几千万个周期。
		程序的局部性属性对程序的性能有着重大的影响。
		RAM，DRAM，ROM,机器硬盘，固态硬盘
	
2  存储技术
		随机访问存储器(Random-Access memory)。分为静态和动态存储器，SRAM和DRAM。
		SRAM使用双稳态的存储器单元存储位，每个双稳态由六个晶体管组成，它只有两种状态，其它任何状态都是不稳定的，会恢复到稳定状态，他能抵抗电子干扰。
		DRAM将位存储位对一个电容的充电，每个存储单元由一个电容和一个访问晶体管组成。DRAM对电子干扰非常敏感，并且不可恢复。DRAM必须周期性的刷新。
				每位晶体管数			相对访问时间		持续性			敏感性			相对造价			应用
		SRAM		6						1				  是			  否			   100		   高速缓存存储器 
		DRAM 		1						10				  否			  是				1		   主存，帧缓冲区
		
3	传统的DRAM
		每个位都划分到一个超单元中，存储由超单元组成，所有超单元被组织成一个二位的数组。(i，j)。
		DRAM芯片通过引脚与存储控制器相连，引脚分为地址引脚和数据引脚，地址引脚传递访问地址，数据引脚传递访问数据。
		存储控制器将逻辑地址，转换位(i,j)格式的访问地址，i - RAS(Row access strobe)行访问选通脉冲  j - CAS (column access strobe)列访问选通脉冲
		访问过程：先发送行RAS，DRAM将相应行数据访问高速缓存区，再发送CAS，DRAM在高数缓存区取出相应数据。
		将DRAM组织成二维阵列而不是线性数组，主要是为了减少引脚数量。
		
4  	存储器模块
		DRAM芯片包装在存储器模块(memory module)中，它是插到主板的扩展槽上的，常见的包装包括168个引脚的双列直插存储器模块(Dual Inline Memory Module)
		它以64位为块传送数据，和72个引脚的单列直插存储器模块(Single Inline Memory Module)以32为块传送数据。
		
5 	增强的DRAM
		快页模式DRAM(Fast Page Mode DRAM,FPM DRAM),
		扩展数据输出DRAM(Extended Data Out DRAM EDO DRAM)
		同步DRAM(Synchronous DRAM,SDRAM)
		双倍速率同步DRAM(Double Data-rate synchronous DRAM)
		Rambus DRAM(RDRAM)
		视频DRAM(Video DRAM,VDRAM)
		
		主流是使用Double Data-rate synchronous DRAM 例如 DDR3 DRAM
		
6	非易失性存储器
		PROM(Programmable ROM，可编程ROM)，只能被编程一次。
		可擦写可编程ROM(Erasable Programmable ROM,EPROM)
		闪存(flash memory)
		
		存储在ROM中的程序通常被称为固件(firmware)
		
7 	访问主存
		总线：共享电子电路。
		总线事务：数据传递和处理通过一系列步骤完成，这些步骤就称为总线事务。
		总线传递的信息可分为：地址，数据，控制信号。
		计算机系统的主要模块：cpu芯片，I/O桥的芯片组，DRAM存储器模块。
		系统总线：连接cpu与i/o桥。存储器总线：连接i/o桥与DRAM。i/o总线：连接i/o桥与i/o设备。
		
		
		
		
		
		
		
		
														第九章 异常控制
1 给处理器加电运行知道断电，程序计数器假设一个序列的值 a1 a2 a3 a4....ak，其中ak对应指令lk。从ak到ak+1的过度称为控制转移。这样的控制转移序列称为控制流(control flow)
2 最简单的控制流称为平滑控制流，lk和lk+1在存储器位置相邻。典型的平滑流的突变也就是lk与lk+1不相邻.诸如：跳转，调用，返回。程序需要能够对系统状态的变化做出反应																				
3 程序需要能够对系统的变化做出反应，，诸如：硬件定时器，包到达网络适配器，被通知i/o，子进程终止后父进程必须得到通知。
  现代系统通过控制流突变来对这些情况做出反应:ECF exceptional oontrol flow.异常控制流。
4 异常控制流可以发生在系统的各个层次。硬件：检测到事件。操作系统：进程上下文转换。进程：进程间通信。
5 ECF是系统实现I/O，虚拟存储器，进程的基本创建机制。应用程序与操作系统交互，软件异常如何工作。
6 异常是控制流的突变，用于响应处理器状态的变化，状态处理称为事件。当处理器检测到事件发生时，它会通过一张异常表，跳转到相应异常处理程序。
  异常处理完成后，可能将控制权返回到当前指令，或者下一条指令，或者终止程序。
7 每种异常都分配了一个非负整数的异常号，一些是由处理器分配的如：除零，缺页，存储器访问违例，断点，算术溢出。一些是有操作系统内核分配的，如：系统调用，外部i/o设备信号。
  系统启动时，处理器分配和初始化异常表，使得表目k包含异常k的处理程序的地址。
8 异常处理过程：程序运行时，处理器检测到异常，并且确定其异常号，处理器触发异常，方法是执行间接过程调用，通过异常表跳转到相应异常处理程序。
9 异常过程调用与一般过程调用的区别：
	1 过程调用时，在跳转到处理程序之前，处理器将返回地址压入到栈中，返回地址要不时当前指令，要不是下一条指令。
	2 处理器也把一些额外的处理器状态压入栈中，在程序返回时重新开始被中断的程序需要这些状态。
	3 如果控制在内核状态，所以的项目都被压入内核栈，而不是用户栈。
	4 异常处理程序运行在内核状态，对系统资源具有完全的访问权。
10 异常类型：中断，陷阱，故障，终止。
    类别		原因			异步/同步		返回行为
	中断      i/o设备信号         异步           总是返回到下一条指令
	陷阱      有意的异常		  同步           总是返回到下一条指令 
	故障      潜在的可恢复的错误  同步           可能返回到当前指令
	终止      不可恢复的错误      同步            不会返回
	
	异步异常：外部的I/O设备中你给的事件产生的
	同步异常：执行一条指令的直接产物。
  
11 进程：一个执行中程序的实例。
   进程上下文：存储器中的数据和代码，栈，通用目的寄存器，程序计数器，环境变量，打开的文件描述符。
   进程抽象：
		1 一个独立的逻辑控制流，它提供一个假象，程序独占处理器
		2 一个私有的地址空间，它提供一个假象，程序独占存储器系统
12 进程为每个程序提供一种假设，好像它独占使用系统地址空间，并且空间是私有的。虽然每个进程私有空间相关联的存储器内容一般是不同的，
   但每个这样的空间都有相同的结构。地址空间底部的四分之三是预留给程序的，顶部的四分之一是留给内核的。
13 操作系统为进程提供了两种运行模式：内核模式和用户模式。处理器通过某个寄存器中的一个方式位提供这种功能。
   内核模式：可以执行指令集中的所有指令，访问存储器中的任何位置。
   用户模式：不可以执行特权指令，如：停止处理器，改变方式位，执行i/o请求。也不可以引用内核区的代码和数据。
   进程初始是运行在用户模式，只能通过异常(中断，陷阱，故障)进入内核模式，当返回应用代码时，处理器又回到用户模式。   
14 进程上下文：内核重新启动一个呗抢占进程所需的状态。包括：通用目的寄存器，浮点寄存器，状态寄存器，程序计数器，用户栈，内核栈和各种内核数据结构。
   上下文切换：保存当前进程的上下文，恢复某个先前被抢占进程所保存的上下文，将控制权传递给恢复进程。
15 系统调用：操作系统内核为应用程序提供的服务接口。Linux大约提供了160个系统调用。标准c库提供了一组对常用系统调用的包装函数。
   系统级函数：系统调用以及其包装函数。
16 进程控制。
		1 获取进程id，每个进程都有一个整数非0的进程ID。
			getpid函数获取调用进程id
			getppid获取调用进程父进程id
		2 创建和终止进程：进程状态有三种：
			运行：进程正在cpu执行或者正在等待调度执行。
			暂停：进程的执行被挂起(suspended)且不会被调度。
			终止：进程永远停止，进程有三种终止原因：收到一个终止信号，从主程序返回，调用exit函数。
			void exit(int status)以status退出状态终止进程。
			pid_t fork(void)创建子进程。子进程返回0，父进程返回子进程PID，出错返回-1。子进程与父进程具有相同虚拟地址空间拷贝，相同描述符拷贝。
		3 回收子进程。进程终止时，内核并不立即把它重系统中清除，进程被保持在一种终止状态中，直到被它的父进程回收。一个终止但还未被回收的进程称为僵死进程(zombie)。
		  如果父进程没有回收僵死的子进程，内核会安排init进程来回收，init的PID为1.
		  pid_t waitpid(pid_t pid,int *status,int options);挂起调用进程执行，直到它的等待集合中一个子进程终止。
		4 进程休眠
			unsigned int sleep(unsigned int secs);使进程休眠一定时间，返回0表明休眠时间到，非0表示剩下休眠的时间，这种情况是被信号中断过早返回。
			int pause(void);使进程休眠，直到进程收到一个信号为止。返回休眠时长。
		5 加载并允许程序。
			int execve(char *filename,char *argv[],char *envp);在当前进程上下文中加载并允许新的程序。
17 进程组。每个进程都属于一个进程组，进程组由一个唯一的正整数标识。
	pid_t getpgrp(void);获取当前进程的进程组id
	pid_t setpgid(pid_t pid,pid_t pgid);设置进程pid的进程组为pgid。
			
18 Unix信号(signal)。Unix信号是高层次的软件异常。一个信号就是一条消息，它通知进程某种类型的事件已经在系统中发生了。每种信号都使用唯一的数字标识。			
	信号发送：内核通过更新目标进程上下文中的某个状态，发送一个信号给目的进程。发送信号两种原因：1 内核检测到一个系统事件。2 进程调用kill函数显示要求内核发送信号给目标进程(或者自己)。
	信号接收：当目标进程被内核以某种强迫对信号做出反应时，信号就被接收了。应用程序可以忽略信息，终止，或者使用信号处理程序的用户级函数捕获。
	待处理信号：被接收但没有处理的信号，一种类型的信息只能由一个待处理信号，信号不会排队，会被简单的丢弃。
	阻塞信息：应用程序可以阻塞某种信息，被阻塞的信号能被发送不能被接收。
	int kill(pid_t pid,int sig);发送信号sig给pid进程，pid=0表示发送给进程所属进程组中的所有进程。
	unsigned int alarm(unsigned int secs);在secs秒内发送一个SIGALRM信号给调用进程，如果当前有待处理的alarm者取消，返回剩余秒数。
19  信号的接收。当内核从一个异常处理程序返回，准备将控制权传递给进程时，它会检查未被阻塞的待处理信号集合,如果为空，则直接返回，
	如果不为空，则选择某个信号并强制进程接收。进程接收信号会触发进程的某种行为，一旦进程完成了这个行为，控制流传递给进程的逻辑控制流的中。
	每种信号都有默认的信号处理行为：
		1 进程终止 2进程终止并转存存储器。 3进程暂停直到被SIGCONT信号重启。 4进程忽略该信号。
	使用signal函数可以修改默认行为，唯一例外，SIGSTOP SIGKILL，它们不能被修改。
	handler_t *signal(int signum,handler_t *handler);signum信息id，handler信号处理程序
20 非本地跳转。c语言提供了一种形式的用户级异常控制流，称为非本地跳转(nonlocal jump)。它将控制返回到另一个当前正在执行的函数。而不是通过正常的调用-返回序列。
	int setjmp(jmp_buf env);
	int signsetjmp(sigjmp_buf env,int savesigs);
	void longjmp(jmp_buf env,int retval);
	void siglongjmp(sigjmp_buf env,int retval);
			
		
		
		
		
		
		
																						第十三章 并发编程
1 并发(concurrent):	逻辑控制流在时间上重叠。
2 构建应用级并发的几种方式：
	1 进程：每个控制流都是一个进程，由内核来调度维护。
	2 i/o多路复用：应用程序在进程上下文中显示的调度自己的控制流。每个控制流都被模型化为状态机，作为数据到文件描述符的结果，主程序从一个状态转换为另一个状态。
	3 线程：在进程上下文中的控制流，由内核进行调度维护。
3 共享变量：被多个线程引用的变量。
4 线程的存储模型：每个线程都有自己的线程上下文，包括唯一的整数线程ID,栈，栈指针，程序计数器，通用目的的寄存器和条件码。线程之间共享整个进程的上下文。
				  线程能够访问进程的整个虚拟存储器空间，所有线程能够访问其它线程除了寄存器的所有内存空间。
5 将变量映射到存储器。
	1 全局变量，定义在函数外的变量。在运行时虚拟存储器的读写区域只包含每个全局变量的一个实例。
	2 本地自动变量，定义在函数内部并且没有static属性的变量。在运行时每个线程的栈都包含它自己的所有本地自动变量的实例。
	3 本地自动变量，定义在函数内部并且有static属性的变量。和全局变量一样，虚拟存储器中的读写区域只包含一个实例。
6 信号量(semphore)
	信号量是一种特殊类型的变量s，只能由两种特殊的变量来处理，称为P和V。
	P:如果s为非0，则s减一，并且立即返回，如果s为0则，阻塞线程。
	V：s加一，唤醒一个正在P阻塞的线程。
7 线程安全函数：当且仅当线程被多个线程调用，总能产生正确的结果。
  线程不安全函数：
		1、不包含共享变量
		2、保持跨越多个调用的状态的函数
		3、返回指向静态变量的函数
		4、调用线程不安全函数的函数
8 可重用函数：不会引用任何共享变量的函数。可重用函数是线程安全的，它是线程安全函数的真子集。
9 竞争：程序的正确性依赖线程之间的执行轨迹。
10 死锁：线程等待一个永远不会为真的条件。
11 互斥锁加锁的顺序规则：如果对于程序中没对互斥锁(s,t)每个既包含s也包含t的现场都按照相同的顺序同时对它们枷锁，那么这个程序就是死锁的。
12 		
		
		
		
		
		
		
												
			