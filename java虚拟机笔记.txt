
1 java体系结构
	java虚拟机
	java语言
	java api
	class文件

2 java优点
	与平台无关性
		java程序实现了可以不需要改动而在各个软硬件平台上运行
	安全性
		java提供了受保护的运行环境，java提高了程序健壮性
	网络移动性
		java程序可以动态扩展

3 java虚拟机和java api组成java平台。java虚拟机由类加载器和执行引擎组成。
  执行引擎可以由软件实现，也可以由硬件实现。可以一次性解释字节码，或者即时编译，或者自适应优化。


4 java中有两种方法：java方法和本地方法。
	java方法是由java语言编写，编译的字节码。
	本地方法是由其它语言编写，编译生成的代码（c,c++,汇编）。

5 java类装载系统：负责装载java class文件
	启动类装载系统：由java虚拟机实现
	用户自定义装载系统：由程序使用java语言实现

6 java Class文件
	java class文件是特定格式的可以被java虚拟机执行的二进制文件。
	传统的可执行文件是首先被编译，链接成单独的支持特定硬件平台和操作系统的二进制文件。
	java可执行文件是以类型划分的java class文件集合。
	所有被装载的class文件（包括从程序中和java api中）和所有已经被装载的动态库共同组成的java虚拟机上运行的整个程序。

7 java优缺点
	优点：面向对象，多线程，结构化错误处理，垃圾收集，动态链接，动态扩展。	
	缺点：执行速度，实时性（垃圾收集器影响），安全（易反编译）


													第三章 安全性

1，java安全模型
	1.0 基本的沙箱 
	1.1 代码签名和认证
	1.2 细粒度访问控制

1.1 基本沙箱
	1 类装载器结构
	2 class文件检验器
	3 内置于java虚拟机及语言的安全特性
	4 安全管理器及Java Api

1.1.1 类装载器
 	1 防止恶意代码去干涉善意代码，守护了被信任类库的边界，将代码归入某类，确定了代码可以进行哪些操作。
	2 双亲委托机制
	3 类装载器结构  启动类装载器 - 扩展类装载器 - 系统类装载器 - 用户自定义装载器
	4 类命名空间
	5 运行时包：在同一个包内并且是由同一个类装载器装载的类型集合

1.1.2 class文件检验器
	1 和类装载器一起，class文件检查器保证装载的clss文件内容有正确的内部结构，并且这些class文件之间相互协调一致。
	2 class文件检验器在字节码执行之前要完成大部分检验
	3 class文件检验器要执行四趟独立的扫描来完成。第一次在装载时，检测class文件的内部结构，保证它可以被安全的编译。
	  第二次和第三次在连接过程中进行，确认数据类型遵循java编程语言的语义，确保字节码的完整性，第四次是在动态连接过程中
	  解析符号引用时进行的，确认被引用的类，字段，方法确实存在。
	4 第一趟：字节码结构检查。检查字节码，是否符合class文件的基本结构，魔数，class文件主版本和次版本是否被java虚拟机支持，class文件长度。
	5 第二趟：类型数据的语义检查。检查方法区数据，
	6 第三趟：字节码码流验证。
	7 第四趟：符号引用的验证。在程序真正执行到时才去验证。
	8 动态连接：将符号引用解析为直接引用的过程。
	9 动态连接过程：
		1 查找被引用的类（如果有必要的话装载）
		2 将符号引用替换为直接引用，例如指向一个类，字段或方法的指针或偏移量。
	10 二进制兼容。class文件相互引用是否兼容。

1.1.3 java虚拟机内置的安全特性
	类型安全的引用转换
	结构化的内存访问（无指针算法）
	自动垃圾收集
	数组边界检查
	空指针检查

1.1.4 安全管理器和Java API
	1,java装载器，java class文件检查器，java虚拟机内置的安全特性：保护java虚拟机实例和它运行的程序的内部资源。
	  java安全管理器和Java api是保护虚拟机外部资源。
	2 java安全管理器是可定制的
	
	
1.2 代码签名了认证
	1 非对称加密，散列算法。	
	2 加密过程：使用散列算法对jar文件进行散列，然后使用私钥对散列加密，将加密后密文添加到jar文件中，随jar包一起发布。
	3 解密过程：使用证书对密文解密，得到散列值，对jar包进行散列，与解密得到的散列值进行对比。
	4 证书制作和发布：1 使用keytool工具生成keystore文件（自签名证书） 2，使用jarsigner工具对jar文件进行签名。必须发布公钥
	
	
1.3 细粒度访问控制
	1 CodeSource代码来源、Certificate证书、Permission权限、Policy权限策略、ProtectionDomain保护域
	2 java中每个class文件都与一个CodeSource关联,CodeSource确定了代码加载的URI，证书。
	  类装载器知道所有类型的代码库和签名，利用这些信息创建CodeSource
	3 java可使用ASCII策略文件说明Policy，使用Policy来确认CodeSource所拥有的权限。
	4 每个类型都属于一个ProtectionDomain，ProtectionDomain中包含的CodeSource和Permissions,
	  在类加载时会为每个类型指定保护域。
	5 虽然Policy说明了一个CodeSource拥有的Permission，但是最终决定权限赋予的还是类加载器，类加载器具有更改权限的功能。
		
		
1.4 访问控制器（AccessController）
	1 SercurityManager是调用AccessController实现的。
	2 SercurityManager.checkPermission(Permission) -  AccessController.checkPermission(Permission)
	  检查当前线程的调用栈是否有权限执行相应操作。
	3 Permission.implies(Permission) 检查当前权限是否包含指定权限
	  PermissionCollection.implies(Permission) 检查当前权限集是否包含指定权限
	  ProtectionDomain.implies(Permission)   检查当前保护域是否包含指定权限
	4 权限检查过程：自栈顶到栈底依次检查每个栈帧，只要一个栈帧没有权限则检查失败。
    5 AccessController.doPrivileged(PrivilegedAction)给予doPriviliedged()下的栈帧特权，只检查到doPrivileged()的上一个栈帧。
	  
	  
1.5 java安全模型的不足和今后的发展
	1 不足：
		1 不断分配内存直到内存耗尽
		2 不断生成线程导致cpu资源紧张。
	2 发展 
		基于用户的权限
	
	
					
					
											第四章 网络移动性
1   java的平台无关性和安全性为网络移动带来了巨大支持
2   java的动态连接和动态扩展性。




											第五章 java虚拟机
		
1.1 java虚拟机是什么		
	1 虚拟机 是由一个规范定义的抽象计算机。
	2 java虚拟机概念: 1 一个抽象规范  2 一个具体实现 3 一个运行中的虚拟机实例
	
1.2 虚拟机的生命周期
	1java虚拟机在启动程序的时候创建，在退出程序的时候销毁。
	2当所有非守护线程都结束的时候，jvm会自动退出。如果安全管理器允许调用Runtime或System的exit()方法可以退出jvm。
	
1.3 java虚拟机的体系结构
	1 所有java虚拟机的实现都必须遵守java虚拟机规范，java虚拟机规范只规定了外部行为，没有规定其具体实现，
	  它可以通过软件实现，或者软硬件结合实现。
	2 子系统、内存区、数据类型、指令集。
		子系统：类加载子系统，负责加载及验证class文件。
		内存区：方法区，堆，java栈，pc寄存器，native栈
		数据类型：基本类型：int long short byte char float double boolean、引用类型、returnAdress
	3	方法区存储被解析后的class文件二进制类型信息。堆存储创建的类型对象。
	    java栈存储方法执行的状态信息。pc寄存器存储下一条被执行的指令。native栈存储native方法执行的状态信息。
		方法区和堆信息被所有线程共享，java栈和native栈和pc寄存器是线程私有的。
	4   java栈：指令，方法参数，返回值，局部变量，操作数栈
	5   byte 8位，带符号，二进制补码  -2^7 - 2^7-1
		short 16位 带符号，二进制补吗 -2^15 - 2^15-1
		char 16位  不带符号，Unicode字符 0 - 2^16-1
		int 32位 带符号，二进制补码 -2^31 - 2^31-1
		long 64位 带符号，二进制补码 -2^63 - 2^63-1
		float 32位 IEEE754标准单精度浮点数
		double 64位，IEEE754标准双精度浮点数
		reference：堆中某对象的应用，或者null
		boolean：由byte或者int实现
	6  java虚拟机最基本的数据单元是字(word)，大小由虚拟机的设计者决定，字长必须足够大，至少是一个字长就能容纳
		int short byte char returnAdress reference，而两个字长就能容纳long或者double。java运行时数据大部分都是基于字的
		，局部变量和操作数栈都是按照字来定义的。这些内存区域能够容纳任何虚拟机数据类型的值。它们占有一个或两个字。
	7  java类装载器分两种：启动类装载器和用户自定义类装载器，前者是java虚拟机实现的后者是java程序的一部分。
	8  类装载器执行过程：装载 - 连接 - 初始化
	   装载：查找并装载类型的二进制数据
	   连接：执行验证：确保被导入的类型的正确性
			 准备：位类变量分配内存，并将其初始化位默认值
			 解析：把类型中的符号引用转换为直接引用(可选)
	   初始化：把类变量初始化位正确的初始值。	 
		
	9   defineClass(String name,byte[] data,int offset,int length);
		加载类，指定默认保护域
		defineClass(String name,byte[] data[],int offset,int length,ProtectionDomain protectionDomain);
		加载类，指定其保护域
		findSystemClass(String name);
		调用系统加载器加载类
		resolveClass(Class cls);
		解析类型


	10  java方法区
		1、java方法区是存储被解析后的class二进制数据的逻辑区域。
		2、java虚拟机规范并没有对方法区的数据结构做任何规范，它是由java虚拟机的设计者决定的。
		3、java方法区数据被所有线程共享，必须通过线程安全的方式访问。
		4、java方法区大小可以动态调整，不必是连续的，可以在堆中自由分配，允许用户指定初始大小及最大和最小尺寸。
		5、java方法区也可以被垃圾收集器收集，可以卸载不再使用的类型。
		6、java方法区存储的数据内容：
				1 类型的全限定名
				2 类型的直接超类的全限定名(除了Object)
				3 类型的访问修饰符(public、abstract或者final的子集)
				4 任何直接超接口的全限定名的有序列表
				5 常量池
				6 字段信息
				7 方法信息
				8 静态变量
				9 一个到类ClassLoader对象的引用
				10 一个到类Class对象的引用
		7、java虚拟机必须为每一个被装载的类型维护一个常量池，常量池是该类型所用常量的一个有序集合，包括直接常量(string,integer,floating,point)
		   和对其他类型，字段和方法的符号引用。池中的数据就像数组一样通过索引访问。
		8、字段信息：字段名、字段类型、字段访问修饰符(public、private、protected、static、final、volatile、transient)，声明顺序也必须保存
		9、方法信息：方法名、方法的返回类型、方法的参数数量和类型(按声明顺序)、方法的修饰符(public、private、protected、static、final、synchronized、native、abstract)	
					 、方法的字节码、操作数栈和该方法的线帧中的局部变量区的大小、异常表。
		10、编译时常量：使用final声明的并且用编译期已知的值初始化的类变量。
		11、指向ClassLoader类的引用：每一个由用户自定义类加载器加载的类型，都会在方法区存储堆该加载器的引用。
		12、指向Class类的引用：每一个被装载的类型，虚拟机都会相应的位它创建一个Class类的实例，虚拟机会将这个实例与方法区数据关联起来。
		13、java堆
				1 java堆存储所有运行时类实例和数组。一个虚拟机中只有一个堆。堆被所有线程共享
				2 java堆是可以动态收缩的，并且不必是连续的。
				3 java中对象的销毁由java虚拟机负责。java垃圾收集器负责销毁所有不再使用的对象和类型信息，负责内存碎片整理。
				4 java对象中包含的基本数据由它所属的类及所有超类声明的实例变量组成。
				5 通过对象引用，java虚拟机必须能快速访问对象实例数据和类型数据(方法区类型信息)
				6 对象数据的内部表示：
						1 一种把堆分为两部分：一个句柄池，一个对象池，对象引用就是指向句柄池的本地指针。句柄池分为两个部分，一个
						  指向对象的指针，一部分为指向方法区类型数据的指针。这种设计有利于碎片的整理，当移动对象时只需要修改句柄池的对象指针就行，	
						  缺点是每次访问对象的实例都需要经过两次指针跳转。
						2 使对象引用指向一组数据，该数据包括对象实例数据及指向方法区中的类型数据的指针。
						  这样设计的优缺点于前面相反，通过一个指针就可以访问实例数据，但当移动对象时，必须在整个运行时数据区中更新指向被移动对象的引用。
		



		

	